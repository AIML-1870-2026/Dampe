<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Julia Set Explorer</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin:0; padding:0; box-sizing:border-box; }
:root {
  --bg:#0a0a0f; --panel-bg:rgba(16,16,28,0.85); --panel-border:rgba(255,255,255,0.06);
  --text:#e0e0e0; --text-dim:#888; --accent-1:#ff6b9d; --accent-2:#c86dd7;
  --accent-gradient:linear-gradient(135deg,var(--accent-1),var(--accent-2));
  --glow:rgba(200,109,215,0.3); --input-bg:rgba(255,255,255,0.06);
  --input-border:rgba(255,255,255,0.1); --hover-bg:rgba(255,255,255,0.08);
  --radius:8px; --radius-sm:5px;
  --font:'Inter',-apple-system,BlinkMacSystemFont,sans-serif;
  --mono:'JetBrains Mono','Fira Code',monospace;
}
html,body { width:100%; height:100%; overflow:hidden; background:var(--bg); color:var(--text); font-family:var(--font); font-size:13px; }
canvas#julia { position:absolute; top:0; left:0; width:100%; height:100%; cursor:grab; display:block; }
canvas#julia:active { cursor:grabbing; }

.top-bar { position:fixed; top:0; left:0; right:0; height:48px; display:flex; align-items:center; gap:12px; padding:0 16px; background:linear-gradient(180deg,rgba(10,10,15,0.9) 0%,rgba(10,10,15,0) 100%); pointer-events:none; z-index:100; }
.top-bar>* { pointer-events:auto; }
.menu-toggle { width:36px; height:36px; border:1px solid var(--input-border); border-radius:var(--radius-sm); background:var(--panel-bg); color:var(--text); font-size:16px; cursor:pointer; display:flex; align-items:center; justify-content:center; backdrop-filter:blur(12px); transition:all 0.2s; }
.menu-toggle:hover { border-color:var(--accent-1); box-shadow:0 0 12px var(--glow); }
.app-title { font-size:15px; font-weight:500; letter-spacing:0.5px; background:var(--accent-gradient); -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text; }

.zoom-buttons { position:fixed; bottom:56px; right:16px; display:flex; flex-direction:column; gap:6px; z-index:100; }
.zoom-btn { width:40px; height:40px; border:1px solid var(--input-border); border-radius:var(--radius-sm); background:var(--panel-bg); backdrop-filter:blur(12px); color:var(--text); font-size:20px; font-weight:300; cursor:pointer; display:flex; align-items:center; justify-content:center; transition:all 0.2s; line-height:1; }
.zoom-btn:hover { border-color:var(--accent-1); box-shadow:0 0 12px var(--glow); }
.zoom-btn:active { transform:scale(0.92); }

.info-overlay { position:fixed; bottom:12px; left:50%; transform:translateX(-50%); display:flex; gap:16px; padding:6px 16px; background:var(--panel-bg); backdrop-filter:blur(12px); border:1px solid var(--panel-border); border-radius:20px; font-family:var(--mono); font-size:12px; color:var(--text-dim); z-index:100; pointer-events:none; white-space:nowrap; }

.control-panel { position:fixed; top:56px; left:12px; bottom:50px; width:280px; background:var(--panel-bg); backdrop-filter:blur(16px); border:1px solid var(--panel-border); border-radius:var(--radius); overflow-y:auto; overflow-x:hidden; z-index:90; scrollbar-width:thin; scrollbar-color:rgba(255,255,255,0.1) transparent; }
.control-panel::-webkit-scrollbar { width:4px; }
.control-panel::-webkit-scrollbar-thumb { background:rgba(255,255,255,0.1); border-radius:2px; }
.control-panel.hidden { display:none; }

.panel-section { border-bottom:1px solid var(--panel-border); }
.panel-section:last-child { border-bottom:none; }
.section-header { width:100%; display:flex; justify-content:space-between; align-items:center; padding:10px 14px; background:none; border:none; color:var(--text); font-family:var(--font); font-size:12px; font-weight:600; text-transform:uppercase; letter-spacing:0.8px; cursor:pointer; transition:background 0.15s; }
.section-header:hover { background:var(--hover-bg); }
.chevron { font-size:10px; color:var(--text-dim); }
.section-content { padding:4px 14px 14px; display:flex; flex-direction:column; gap:10px; animation:fadeIn 0.15s ease; }
.section-content.collapsed { display:none; }

.slider-label { display:flex; flex-direction:column; gap:4px; }
.slider-label>span { font-size:11px; color:var(--text-dim); font-family:var(--mono); }
.slider-row { display:flex; gap:8px; align-items:center; }
.slider-row input[type="range"] { flex:1; }
input[type="range"] { -webkit-appearance:none; appearance:none; width:100%; height:4px; background:var(--input-bg); border-radius:2px; outline:none; cursor:pointer; }
input[type="range"]::-webkit-slider-thumb { -webkit-appearance:none; appearance:none; width:14px; height:14px; border-radius:50%; background:var(--accent-gradient); cursor:pointer; box-shadow:0 0 8px var(--glow); transition:transform 0.15s; }
input[type="range"]::-webkit-slider-thumb:hover { transform:scale(1.2); }
input[type="range"]::-moz-range-thumb { width:14px; height:14px; border-radius:50%; background:var(--accent-1); cursor:pointer; border:none; box-shadow:0 0 8px var(--glow); }
.num-input { width:72px; padding:4px 6px; background:var(--input-bg); border:1px solid var(--input-border); border-radius:var(--radius-sm); color:var(--text); font-family:var(--mono); font-size:11px; outline:none; transition:border-color 0.2s; }
.num-input:focus { border-color:var(--accent-1); box-shadow:0 0 6px var(--glow); }

.checkbox-label { display:flex; align-items:center; gap:8px; font-size:12px; cursor:pointer; }
.checkbox-label input[type="checkbox"] { -webkit-appearance:none; appearance:none; width:16px; height:16px; border:1px solid var(--input-border); border-radius:3px; background:var(--input-bg); cursor:pointer; position:relative; transition:all 0.2s; flex-shrink:0; }
.checkbox-label input[type="checkbox"]:checked { background:var(--accent-gradient); border-color:var(--accent-1); }
.checkbox-label input[type="checkbox"]:checked::after { content:'✓'; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:11px; color:white; font-weight:bold; }

.action-button, .link-button { width:100%; padding:8px 12px; background:var(--input-bg); border:1px solid var(--input-border); border-radius:var(--radius-sm); color:var(--text); font-family:var(--font); font-size:12px; cursor:pointer; transition:all 0.2s; text-align:center; }
.action-button:hover, .link-button:hover { background:var(--hover-bg); border-color:var(--accent-1); box-shadow:0 0 8px var(--glow); }
.action-button.active, .link-button.active { background:linear-gradient(135deg,rgba(255,107,157,0.2),rgba(200,109,215,0.2)); border-color:var(--accent-2); }
.small-button { padding:4px 10px; background:var(--input-bg); border:1px solid var(--input-border); border-radius:var(--radius-sm); color:var(--text); font-family:var(--font); font-size:11px; cursor:pointer; transition:all 0.2s; }
.small-button:hover { border-color:var(--accent-1); }

.palette-grid { display:flex; flex-direction:column; gap:6px; }
.palette-swatch { display:flex; align-items:center; gap:10px; padding:6px 8px; background:none; border:1px solid transparent; border-radius:var(--radius-sm); cursor:pointer; transition:all 0.2s; text-align:left; }
.palette-swatch:hover { background:var(--hover-bg); }
.palette-swatch.active { border-color:var(--accent-1); background:rgba(255,107,157,0.08); }
.swatch-gradient { width:80px; height:18px; border-radius:3px; flex-shrink:0; }
.swatch-name { font-size:11px; color:var(--text-dim); white-space:nowrap; }

.custom-gradient-editor { display:flex; flex-direction:column; gap:8px; }
.gradient-preview { width:100%; height:24px; border-radius:var(--radius-sm); border:1px solid var(--input-border); }
.color-stops { display:flex; gap:4px; flex-wrap:wrap; }
.color-stop { display:flex; flex-direction:column; align-items:center; gap:2px; }
.color-stop input[type="color"] { width:28px; height:28px; padding:0; border:1px solid var(--input-border); border-radius:4px; background:none; cursor:pointer; }
.color-stop input[type="color"]::-webkit-color-swatch-wrapper { padding:2px; }
.color-stop input[type="color"]::-webkit-color-swatch { border-radius:2px; border:none; }
.stop-label { font-size:9px; color:var(--text-dim); font-family:var(--mono); }

.preset-grid { display:flex; flex-direction:column; gap:4px; }
.preset-button { display:flex; flex-direction:column; gap:2px; padding:8px 10px; background:none; border:1px solid transparent; border-radius:var(--radius-sm); cursor:pointer; text-align:left; color:var(--text); transition:all 0.2s; }
.preset-button:hover { background:var(--hover-bg); border-color:var(--input-border); }
.preset-name { font-size:12px; font-weight:500; }
.preset-desc { font-size:10px; color:var(--text-dim); }
.preset-params { font-size:10px; font-family:var(--mono); color:var(--accent-1); opacity:0.7; }

.anim-section h4 { font-size:11px; font-weight:500; color:var(--text-dim); margin-bottom:6px; }
.anim-endpoints { display:flex; flex-direction:column; gap:6px; margin-bottom:8px; }
.endpoint { display:flex; align-items:center; gap:6px; font-size:11px; }
.endpoint-label { font-weight:500; width:36px; flex-shrink:0; }
.endpoint-value { flex:1; font-family:var(--mono); font-size:10px; color:var(--text-dim); }
.anim-mode-row { display:flex; gap:4px; }
.mode-button { flex:1; padding:5px 4px; background:var(--input-bg); border:1px solid var(--input-border); border-radius:var(--radius-sm); color:var(--text-dim); font-size:10px; cursor:pointer; transition:all 0.2s; }
.mode-button.active { color:var(--text); border-color:var(--accent-2); background:rgba(200,109,215,0.15); }
.playback-controls { display:flex; gap:6px; margin-top:4px; }
.play-button { flex:1; padding:8px 12px; background:var(--input-bg); border:1px solid var(--input-border); border-radius:var(--radius-sm); color:var(--text); font-size:12px; cursor:pointer; transition:all 0.2s; }
.play-button.active { background:linear-gradient(135deg,rgba(255,107,157,0.25),rgba(200,109,215,0.25)); border-color:var(--accent-1); box-shadow:0 0 12px var(--glow); }

* { scrollbar-width:thin; scrollbar-color:rgba(255,255,255,0.1) transparent; }
@media (max-width:640px) { .control-panel { width:calc(100% - 24px); left:12px; right:12px; max-height:50vh; } .app-title { font-size:13px; } }
@keyframes fadeIn { from { opacity:0; transform:translateY(-4px); } to { opacity:1; transform:translateY(0); } }
</style>
</head>
<body>

<canvas id="julia"></canvas>

<div class="top-bar">
  <button class="menu-toggle" id="menuToggle" title="Toggle controls">☰</button>
  <h1 class="app-title">Julia Set Explorer</h1>
</div>

<div class="control-panel" id="controlPanel">
  <!-- Parameters -->
  <div class="panel-section">
    <button class="section-header" data-section="parameters"><span>Parameters</span><span class="chevron">▾</span></button>
    <div class="section-content" id="sec-parameters">
      <label class="slider-label"><span id="lbl-creal">c real: -0.3910</span>
        <div class="slider-row"><input type="range" id="creal" min="-2" max="2" step="0.001" value="-0.391"><input type="number" class="num-input" id="creal-num" min="-2" max="2" step="0.001" value="-0.391"></div>
      </label>
      <label class="slider-label"><span id="lbl-cimag">c imag: -0.5870</span>
        <div class="slider-row"><input type="range" id="cimag" min="-2" max="2" step="0.001" value="-0.587"><input type="number" class="num-input" id="cimag-num" min="-2" max="2" step="0.001" value="-0.587"></div>
      </label>
    </div>
  </div>
  <!-- Rendering -->
  <div class="panel-section">
    <button class="section-header" data-section="rendering"><span>Rendering</span><span class="chevron">▾</span></button>
    <div class="section-content" id="sec-rendering">
      <label class="slider-label"><span id="lbl-iter">Iterations: 200</span><input type="range" id="iterations" min="50" max="1000" step="10" value="200"></label>
      <label class="slider-label"><span id="lbl-escape">Escape Radius: 4.0</span><input type="range" id="escapeRadius" min="2" max="100" step="0.5" value="4"></label>
      <label class="slider-label"><span id="lbl-bright">Brightness: 1.00</span><input type="range" id="brightness" min="0.2" max="2.0" step="0.05" value="1"></label>
      <label class="checkbox-label"><input type="checkbox" id="smoothColoring" checked><span>Smooth coloring</span></label>
      <label class="checkbox-label"><input type="checkbox" id="antiAlias"><span>Anti-aliasing (slower)</span></label>
    </div>
  </div>
  <!-- Colors -->
  <div class="panel-section">
    <button class="section-header" data-section="colors"><span>Colors</span><span class="chevron">▾</span></button>
    <div class="section-content" id="sec-colors">
      <div class="palette-grid" id="paletteGrid"></div>
      <label class="slider-label"><span id="lbl-cycle">Color Cycle Speed: 0.0</span><input type="range" id="cycleSpeed" min="0" max="5" step="0.1" value="0"></label>
      <button class="action-button" id="toggleGradientEditor">Custom Gradient</button>
      <div class="custom-gradient-editor" id="gradientEditor" style="display:none">
        <div class="gradient-preview" id="gradientPreview"></div>
        <div class="color-stops" id="colorStops"></div>
      </div>
    </div>
  </div>
  <!-- Presets -->
  <div class="panel-section">
    <button class="section-header" data-section="presets"><span>Presets</span><span class="chevron">▸</span></button>
    <div class="section-content collapsed" id="sec-presets">
      <div class="preset-grid" id="presetGrid"></div>
    </div>
  </div>
  <!-- Animation -->
  <div class="panel-section">
    <button class="section-header" data-section="animation"><span>Animation</span><span class="chevron">▸</span></button>
    <div class="section-content collapsed" id="sec-animation">
      <div class="anim-section">
        <h4>Parameter Morph</h4>
        <div class="anim-endpoints">
          <div class="endpoint"><span class="endpoint-label">From:</span><span class="endpoint-value" id="animFromLabel">-0.391 - 0.587i</span><button class="small-button" id="setAnimFrom">Set</button></div>
          <div class="endpoint"><span class="endpoint-label">To:</span><span class="endpoint-value" id="animToLabel">0.285 + 0.010i</span><button class="small-button" id="setAnimTo">Set</button></div>
        </div>
        <label class="slider-label"><span id="lbl-animspeed">Speed: 1.0x</span><input type="range" id="animSpeed" min="0.1" max="5" step="0.1" value="1"></label>
        <div class="anim-mode-row">
          <button class="mode-button active" data-mode="loop">Loop</button>
          <button class="mode-button" data-mode="pingpong">Ping-Pong</button>
          <button class="mode-button" data-mode="oneshot">Oneshot</button>
        </div>
        <div class="playback-controls">
          <button class="play-button" id="playBtn">&#9654; Play</button>
          <button class="small-button" id="resetAnim">&#8634; Reset</button>
        </div>
      </div>
    </div>
  </div>
  <!-- Export -->
  <div class="panel-section">
    <button class="section-header" data-section="export"><span>Export</span><span class="chevron">▸</span></button>
    <div class="section-content collapsed" id="sec-export">
      <button class="action-button" id="exportPNG">Download PNG</button>
      <button class="action-button" id="exportJSON">Export Settings (JSON)</button>
      <button class="action-button" id="importJSON">Import Settings</button>
      <input type="file" id="importFile" accept=".json" style="display:none">
      <button class="action-button" id="copyURL">Copy Share URL</button>
    </div>
  </div>
  <!-- Reset View -->
  <div class="panel-section">
    <div class="section-content"><button class="action-button" id="resetView">Reset View</button></div>
  </div>
</div>

<div class="zoom-buttons">
  <button class="zoom-btn" id="zoomIn" title="Zoom in">+</button>
  <button class="zoom-btn" id="zoomOut" title="Zoom out">&minus;</button>
</div>

<div class="info-overlay">
  <span id="coordDisplay">c = -0.3910 - 0.5870i</span>
  <span id="zoomDisplay">zoom: 1.00x</span>
</div>

<!-- Vertex Shader -->
<script id="vertShader" type="x-shader/x-vertex">#version 300 es
precision highp float;
in vec2 a_position;
out vec2 v_uv;
void main() {
  v_uv = a_position * 0.5 + 0.5;
  gl_Position = vec4(a_position, 0.0, 1.0);
}
</script>

<!-- Fragment Shader -->
<script id="fragShader" type="x-shader/x-fragment">#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 fragColor;
uniform vec2 u_resolution;
uniform vec2 u_center;
uniform float u_zoom;
uniform vec2 u_c;
uniform int u_maxIterations;
uniform float u_escapeRadius;
uniform vec3 u_palette[8];
uniform float u_colorCycleOffset;
uniform float u_brightness;
uniform int u_smoothColoring;
uniform int u_antiAlias;

vec3 getColor(float t) {
  t = fract(t + u_colorCycleOffset);
  float idx = t * 7.0;
  int i = int(floor(idx));
  float f = fract(idx);
  f = f * f * (3.0 - 2.0 * f);
  vec3 c1 = u_palette[i];
  vec3 c2 = u_palette[min(i + 1, 7)];
  return mix(c1, c2, f);
}

float juliaIteration(vec2 z, vec2 c, int maxIter, float escapeR) {
  float r2 = escapeR * escapeR;
  for (int i = 0; i < 1000; i++) {
    if (i >= maxIter) break;
    float x = z.x * z.x - z.y * z.y + c.x;
    float y = 2.0 * z.x * z.y + c.y;
    z = vec2(x, y);
    if (dot(z, z) > r2) {
      if (u_smoothColoring == 1) {
        float sl = float(i) - log2(log2(dot(z, z))) + 4.0;
        return sl / float(maxIter);
      }
      return float(i) / float(maxIter);
    }
  }
  return -1.0;
}

vec3 renderPixel(vec2 fragCoord) {
  float aspect = u_resolution.x / u_resolution.y;
  vec2 uv = (fragCoord / u_resolution - 0.5) * 2.0;
  uv.x *= aspect;
  vec2 z = uv / u_zoom + u_center;
  float t = juliaIteration(z, u_c, u_maxIterations, u_escapeRadius);
  if (t < 0.0) return vec3(0.0);
  return getColor(t) * u_brightness;
}

void main() {
  vec3 color;
  if (u_antiAlias == 1) {
    vec2 fc = gl_FragCoord.xy;
    color = vec3(0.0);
    for (int dx = 0; dx < 2; dx++)
      for (int dy = 0; dy < 2; dy++)
        color += renderPixel(fc + vec2(float(dx), float(dy)) * 0.5 - 0.25);
    color /= 4.0;
  } else {
    color = renderPixel(gl_FragCoord.xy);
  }
  fragColor = vec4(color, 1.0);
}
</script>

<script>
// ===== DATA =====
const palettes = {
  'Vibrant Fire': [{r:.05,g:0,b:.02},{r:.5,g:0,b:0},{r:.9,g:.15,b:0},{r:1,g:.45,b:0},{r:1,g:.75,b:.1},{r:1,g:.95,b:.4},{r:1,g:1,b:.8},{r:.05,g:0,b:.02}],
  'Ocean Deep': [{r:0,g:.02,b:.1},{r:0,g:.1,b:.3},{r:0,g:.2,b:.6},{r:.1,g:.4,b:.8},{r:.2,g:.6,b:.9},{r:.4,g:.8,b:1},{r:.3,g:.2,b:.7},{r:0,g:.02,b:.1}],
  'Electric Dreams': [{r:.05,g:0,b:.15},{r:.3,g:0,b:.6},{r:1,g:0,b:.6},{r:1,g:.2,b:.8},{r:0,g:.9,b:1},{r:.4,g:0,b:1},{r:.9,g:0,b:.4},{r:.05,g:0,b:.15}],
  'Aurora': [{r:0,g:.05,b:.1},{r:0,g:.3,b:.2},{r:0,g:.7,b:.3},{r:.2,g:.9,b:.5},{r:.1,g:.5,b:.8},{r:.3,g:.2,b:.8},{r:.5,g:0,b:.6},{r:0,g:.05,b:.1}],
  'Sunset': [{r:.1,g:0,b:.15},{r:.4,g:0,b:.4},{r:.7,g:.1,b:.5},{r:1,g:.3,b:.4},{r:1,g:.55,b:.2},{r:1,g:.8,b:.3},{r:.8,g:.3,b:.6},{r:.1,g:0,b:.15}],
  'Psychedelic': [{r:1,g:0,b:0},{r:1,g:.65,b:0},{r:1,g:1,b:0},{r:0,g:1,b:0},{r:0,g:.8,b:1},{r:0,g:0,b:1},{r:.7,g:0,b:1},{r:1,g:0,b:.5}],
  'Monochrome': [{r:0,g:0,b:0},{r:.15,g:.15,b:.15},{r:.3,g:.3,b:.3},{r:.5,g:.5,b:.5},{r:.7,g:.7,b:.7},{r:.85,g:.85,b:.85},{r:1,g:1,b:1},{r:0,g:0,b:0}],
  'Frozen': [{r:0,g:0,b:.08},{r:.1,g:.15,b:.4},{r:.3,g:.4,b:.7},{r:.5,g:.7,b:.9},{r:.8,g:.9,b:1},{r:1,g:1,b:1},{r:.4,g:.5,b:.8},{r:0,g:0,b:.08}],
};
const paletteNames = Object.keys(palettes);

const presets = [
  {name:'Dendrite',description:'Tree-like branching structure',c:[0,1],zoom:.8,center:[0,0],palette:'Aurora',iterations:200},
  {name:'Siegel Disk',description:'Smooth disk with intricate boundary',c:[-.391,-.587],zoom:.9,center:[0,0],palette:'Electric Dreams',iterations:300},
  {name:"Douady's Rabbit",description:'Three-armed spiral pattern',c:[-.123,.745],zoom:.85,center:[0,0],palette:'Ocean Deep',iterations:250},
  {name:'Dragon',description:'Dragon-shaped fractal curve',c:[-.8,.156],zoom:.7,center:[0,0],palette:'Vibrant Fire',iterations:300},
  {name:'San Marco',description:'Cathedral-like symmetry',c:[-.75,0],zoom:.9,center:[0,0],palette:'Sunset',iterations:200},
  {name:'Spiral',description:'Elegant spiraling arms',c:[.285,.01],zoom:.8,center:[0,0],palette:'Electric Dreams',iterations:350},
  {name:'Cauliflower',description:'Organic cauliflower-like growth',c:[.25,0],zoom:.7,center:[0,0],palette:'Aurora',iterations:250},
  {name:'Galaxy',description:'Swirling galactic formation',c:[-.4,.6],zoom:.85,center:[0,0],palette:'Ocean Deep',iterations:300},
  {name:'Snowflake',description:'Crystalline snowflake pattern',c:[-.8,.156],zoom:1.2,center:[.15,0],palette:'Frozen',iterations:300},
  {name:'Vortex',description:'Hypnotic swirling vortex',c:[-.7,.3],zoom:.75,center:[0,0],palette:'Psychedelic',iterations:250},
  {name:'Crystal',description:'Geometric crystal formations',c:[.285,.013],zoom:.9,center:[0,0],palette:'Sunset',iterations:350},
  {name:'Lightning',description:'Electric lightning bolts',c:[-.54,.54],zoom:.8,center:[0,0],palette:'Electric Dreams',iterations:250},
];

// ===== STATE =====
const S = {
  c: [-.391, -.587], center: [0, 0], zoom: 1, iterations: 200, escapeRadius: 4,
  paletteName: 'Electric Dreams', palette: palettes['Electric Dreams'],
  brightness: 1, smoothColoring: true, antiAlias: false,
  colorCycleOffset: 0, colorCycleSpeed: 0, resolution: [800, 600],
  animating: false, animSpeed: 1, animMode: 'loop',
  animCFrom: [-.391, -.587], animCTo: [.285, .01], animProgress: 0,
  panelOpen: true,
};

// ===== UTILS =====
function hexToRgb(hex) {
  const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return r ? {r:parseInt(r[1],16)/255, g:parseInt(r[2],16)/255, b:parseInt(r[3],16)/255} : {r:0,g:0,b:0};
}
function rgbToHex({r,g,b}) {
  const h=v=>{const s=Math.round(v*255).toString(16);return s.length===1?'0'+s:s};
  return `#${h(r)}${h(g)}${h(b)}`;
}
function gradientCSS(pal) {
  return 'linear-gradient(to right,' + pal.map((c,i)=>`rgb(${Math.round(c.r*255)},${Math.round(c.g*255)},${Math.round(c.b*255)}) ${(i/(pal.length-1))*100}%`).join(',') + ')';
}
function fmtC(c) { return `${c[0].toFixed(4)} ${c[1]>=0?'+':''} ${c[1].toFixed(4)}i`; }
function fmtC3(c) { return `${c[0].toFixed(3)} ${c[1]>=0?'+':''} ${c[1].toFixed(3)}i`; }

// ===== WEBGL SETUP =====
const canvas = document.getElementById('julia');
const gl = canvas.getContext('webgl2', {antialias:false, preserveDrawingBuffer:true});

function compileShader(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s));
  return s;
}

const vs = compileShader(gl.VERTEX_SHADER, document.getElementById('vertShader').textContent);
const fs = compileShader(gl.FRAGMENT_SHADER, document.getElementById('fragShader').textContent);
const prog = gl.createProgram();
gl.attachShader(prog, vs); gl.attachShader(prog, fs); gl.linkProgram(prog);
if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
gl.useProgram(prog);

// Fullscreen quad
const vao = gl.createVertexArray(); gl.bindVertexArray(vao);
const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
const aPos = gl.getAttribLocation(prog, 'a_position');
gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const uNames = ['u_resolution','u_center','u_zoom','u_c','u_maxIterations','u_escapeRadius',
  'u_colorCycleOffset','u_brightness','u_smoothColoring','u_antiAlias',
  ...Array.from({length:8},(_,i)=>`u_palette[${i}]`)];
const U = {};
uNames.forEach(n => U[n] = gl.getUniformLocation(prog, n));

function setUniforms() {
  gl.uniform2f(U.u_resolution, S.resolution[0], S.resolution[1]);
  gl.uniform2f(U.u_center, S.center[0], S.center[1]);
  gl.uniform1f(U.u_zoom, S.zoom);
  gl.uniform2f(U.u_c, S.c[0], S.c[1]);
  gl.uniform1i(U.u_maxIterations, S.iterations);
  gl.uniform1f(U.u_escapeRadius, S.escapeRadius);
  gl.uniform1f(U.u_colorCycleOffset, S.colorCycleOffset);
  gl.uniform1f(U.u_brightness, S.brightness);
  gl.uniform1i(U.u_smoothColoring, S.smoothColoring ? 1 : 0);
  gl.uniform1i(U.u_antiAlias, S.antiAlias ? 1 : 0);
  for (let i = 0; i < 8; i++) {
    const c = S.palette[i] || {r:0,g:0,b:0};
    gl.uniform3f(U[`u_palette[${i}]`], c.r, c.g, c.b);
  }
}

// ===== RESIZE =====
function resize() {
  const dpr = window.devicePixelRatio || 1;
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  gl.viewport(0, 0, canvas.width, canvas.height);
  S.resolution = [canvas.width, canvas.height];
}
resize();
window.addEventListener('resize', resize);

// ===== RENDER LOOP =====
let lastTime = 0;
function render(time) {
  const dt = lastTime ? (time - lastTime) / 1000 : 0;
  lastTime = time;

  // Color cycling
  if (S.colorCycleSpeed > 0) {
    S.colorCycleOffset = (S.colorCycleOffset + dt * S.colorCycleSpeed * 0.1) % 1;
  }

  // Parameter morph animation
  if (S.animating) {
    S.animProgress += dt * S.animSpeed * 0.3;
    let p = S.animProgress;
    if (S.animMode === 'loop') p = p % 1;
    else if (S.animMode === 'pingpong') p = p % 2;
    else if (S.animMode === 'oneshot') { p = Math.min(p, 1); if (p >= 1) S.animating = false; }
    let t = (S.animMode === 'pingpong' && p > 1) ? 2 - p : p % 1;
    t = t * t * (3 - 2 * t);
    S.c[0] = S.animCFrom[0] + (S.animCTo[0] - S.animCFrom[0]) * t;
    S.c[1] = S.animCFrom[1] + (S.animCTo[1] - S.animCFrom[1]) * t;
    syncSlidersFromState();
    updatePlayBtn();
  }

  gl.useProgram(prog);
  gl.bindVertexArray(vao);
  setUniforms();
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  updateInfoOverlay();
  requestAnimationFrame(render);
}
requestAnimationFrame(render);

// ===== UI UPDATES =====
function updateInfoOverlay() {
  document.getElementById('coordDisplay').textContent = 'c = ' + fmtC(S.c);
  document.getElementById('zoomDisplay').textContent = 'zoom: ' + S.zoom.toFixed(2) + 'x';
}

function syncSlidersFromState() {
  document.getElementById('creal').value = S.c[0];
  document.getElementById('creal-num').value = S.c[0];
  document.getElementById('cimag').value = S.c[1];
  document.getElementById('cimag-num').value = S.c[1];
  document.getElementById('lbl-creal').textContent = 'c real: ' + S.c[0].toFixed(4);
  document.getElementById('lbl-cimag').textContent = 'c imag: ' + S.c[1].toFixed(4);
}

function updateAnimLabels() {
  document.getElementById('animFromLabel').textContent = fmtC3(S.animCFrom);
  document.getElementById('animToLabel').textContent = fmtC3(S.animCTo);
}

function updatePlayBtn() {
  const btn = document.getElementById('playBtn');
  btn.innerHTML = S.animating ? '⏸ Pause' : '&#9654; Play';
  btn.classList.toggle('active', S.animating);
}

// ===== MOUSE INTERACTION =====
let dragging = false, lastMouse = {x:0, y:0};

canvas.addEventListener('mousedown', e => {
  if (e.button !== 0) return;
  dragging = true;
  lastMouse = {x: e.clientX, y: e.clientY};
});

window.addEventListener('mousemove', e => {
  if (!dragging) return;
  const dx = e.clientX - lastMouse.x, dy = e.clientY - lastMouse.y;
  lastMouse = {x: e.clientX, y: e.clientY};
  const aspect = canvas.width / canvas.height;
  S.center[0] += -dx * 2 * aspect / (canvas.clientWidth * S.zoom);
  S.center[1] += dy * 2 / (canvas.clientHeight * S.zoom);
});

window.addEventListener('mouseup', () => dragging = false);

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const factor = e.deltaY > 0 ? 0.9 : 1.1;
  S.zoom = Math.max(0.00001, Math.min(10000000, S.zoom * factor));
}, {passive: false});

// Touch
let touches = [], lastPinchDist = 0;
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  touches = Array.from(e.touches).map(t=>({x:t.clientX,y:t.clientY}));
  if (e.touches.length === 2) {
    const dx = e.touches[1].clientX - e.touches[0].clientX;
    const dy = e.touches[1].clientY - e.touches[0].clientY;
    lastPinchDist = Math.sqrt(dx*dx+dy*dy);
  }
}, {passive:false});

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const cur = Array.from(e.touches);
  if (cur.length === 1 && touches.length >= 1) {
    const dx = cur[0].clientX - touches[0].x, dy = cur[0].clientY - touches[0].y;
    const aspect = canvas.width / canvas.height;
    S.center[0] += -dx * 2 * aspect / (canvas.clientWidth * S.zoom);
    S.center[1] += dy * 2 / (canvas.clientHeight * S.zoom);
  } else if (cur.length === 2 && touches.length >= 2) {
    const dx = cur[1].clientX - cur[0].clientX;
    const dy = cur[1].clientY - cur[0].clientY;
    const dist = Math.sqrt(dx*dx+dy*dy);
    if (lastPinchDist > 0) S.zoom = Math.max(0.00001, Math.min(10000000, S.zoom * dist / lastPinchDist));
    lastPinchDist = dist;
  }
  touches = cur.map(t=>({x:t.clientX,y:t.clientY}));
}, {passive:false});

canvas.addEventListener('touchend', e => {
  touches = Array.from(e.touches).map(t=>({x:t.clientX,y:t.clientY}));
  if (e.touches.length < 2) lastPinchDist = 0;
});

// ===== ZOOM BUTTONS =====
document.getElementById('zoomIn').onclick = () => S.zoom = Math.min(10000000, S.zoom * 1.5);
document.getElementById('zoomOut').onclick = () => S.zoom = Math.max(0.00001, S.zoom / 1.5);

// ===== PANEL TOGGLE =====
document.getElementById('menuToggle').onclick = () => {
  S.panelOpen = !S.panelOpen;
  document.getElementById('controlPanel').classList.toggle('hidden', !S.panelOpen);
  document.getElementById('menuToggle').textContent = S.panelOpen ? '✕' : '☰';
};

// ===== SECTION COLLAPSE =====
document.querySelectorAll('.section-header').forEach(btn => {
  btn.addEventListener('click', () => {
    const sec = btn.dataset.section;
    if (!sec) return;
    const content = document.getElementById('sec-' + sec);
    const chev = btn.querySelector('.chevron');
    content.classList.toggle('collapsed');
    chev.textContent = content.classList.contains('collapsed') ? '▸' : '▾';
  });
});

// ===== PARAMETER SLIDERS =====
function bindSlider(sliderId, numId, lblId, lblPrefix, setter) {
  const slider = document.getElementById(sliderId);
  const num = numId ? document.getElementById(numId) : null;
  const lbl = document.getElementById(lblId);
  const handler = val => { setter(val); lbl.textContent = lblPrefix + val.toFixed(4); if (num) num.value = val; };
  slider.addEventListener('input', () => handler(parseFloat(slider.value)));
  if (num) num.addEventListener('input', () => { const v = parseFloat(num.value); if (!isNaN(v)) { slider.value = v; handler(v); } });
}

bindSlider('creal', 'creal-num', 'lbl-creal', 'c real: ', v => S.c[0] = v);
bindSlider('cimag', 'cimag-num', 'lbl-cimag', 'c imag: ', v => S.c[1] = v);

document.getElementById('iterations').addEventListener('input', e => {
  S.iterations = parseInt(e.target.value);
  document.getElementById('lbl-iter').textContent = 'Iterations: ' + S.iterations;
});
document.getElementById('escapeRadius').addEventListener('input', e => {
  S.escapeRadius = parseFloat(e.target.value);
  document.getElementById('lbl-escape').textContent = 'Escape Radius: ' + S.escapeRadius.toFixed(1);
});
document.getElementById('brightness').addEventListener('input', e => {
  S.brightness = parseFloat(e.target.value);
  document.getElementById('lbl-bright').textContent = 'Brightness: ' + S.brightness.toFixed(2);
});
document.getElementById('smoothColoring').addEventListener('change', e => S.smoothColoring = e.target.checked);
document.getElementById('antiAlias').addEventListener('change', e => S.antiAlias = e.target.checked);

// ===== COLOR PALETTE =====
function buildPaletteGrid() {
  const grid = document.getElementById('paletteGrid');
  grid.innerHTML = '';
  paletteNames.forEach(name => {
    const btn = document.createElement('button');
    btn.className = 'palette-swatch' + (S.paletteName === name ? ' active' : '');
    btn.innerHTML = `<div class="swatch-gradient" style="background:${gradientCSS(palettes[name])}"></div><span class="swatch-name">${name}</span>`;
    btn.onclick = () => {
      S.paletteName = name;
      S.palette = palettes[name];
      buildPaletteGrid();
      buildColorStops();
      updateGradientPreview();
    };
    grid.appendChild(btn);
  });
}
buildPaletteGrid();

document.getElementById('cycleSpeed').addEventListener('input', e => {
  S.colorCycleSpeed = parseFloat(e.target.value);
  document.getElementById('lbl-cycle').textContent = 'Color Cycle Speed: ' + S.colorCycleSpeed.toFixed(1);
});

// Custom gradient editor
let gradientEditorOpen = false;
document.getElementById('toggleGradientEditor').onclick = () => {
  gradientEditorOpen = !gradientEditorOpen;
  document.getElementById('gradientEditor').style.display = gradientEditorOpen ? 'flex' : 'none';
  document.getElementById('toggleGradientEditor').textContent = gradientEditorOpen ? 'Close Editor' : 'Custom Gradient';
  document.getElementById('toggleGradientEditor').classList.toggle('active', gradientEditorOpen);
  if (gradientEditorOpen) { buildColorStops(); updateGradientPreview(); }
};

function updateGradientPreview() {
  document.getElementById('gradientPreview').style.background = gradientCSS(S.palette);
}

function buildColorStops() {
  const container = document.getElementById('colorStops');
  container.innerHTML = '';
  S.palette.forEach((c, i) => {
    const div = document.createElement('div');
    div.className = 'color-stop';
    const inp = document.createElement('input');
    inp.type = 'color'; inp.value = rgbToHex(c);
    inp.addEventListener('input', () => {
      S.palette[i] = hexToRgb(inp.value);
      S.paletteName = 'Custom';
      updateGradientPreview();
      buildPaletteGrid();
    });
    const lbl = document.createElement('span');
    lbl.className = 'stop-label'; lbl.textContent = i + 1;
    div.appendChild(inp); div.appendChild(lbl);
    container.appendChild(div);
  });
}

// ===== PRESETS =====
function buildPresetGrid() {
  const grid = document.getElementById('presetGrid');
  grid.innerHTML = '';
  presets.forEach(p => {
    const btn = document.createElement('button');
    btn.className = 'preset-button';
    btn.innerHTML = `<span class="preset-name">${p.name}</span><span class="preset-desc">${p.description}</span><span class="preset-params">c = ${p.c[0].toFixed(3)} ${p.c[1]>=0?'+':''} ${p.c[1].toFixed(3)}i</span>`;
    btn.onclick = () => {
      S.c = [...p.c]; S.center = [...p.center]; S.zoom = p.zoom;
      S.iterations = p.iterations; S.paletteName = p.palette;
      S.palette = palettes[p.palette] || S.palette;
      syncSlidersFromState();
      document.getElementById('iterations').value = S.iterations;
      document.getElementById('lbl-iter').textContent = 'Iterations: ' + S.iterations;
      buildPaletteGrid();
      if (gradientEditorOpen) { buildColorStops(); updateGradientPreview(); }
    };
    grid.appendChild(btn);
  });
}
buildPresetGrid();

// ===== ANIMATION =====
document.getElementById('setAnimFrom').onclick = () => { S.animCFrom = [...S.c]; updateAnimLabels(); };
document.getElementById('setAnimTo').onclick = () => { S.animCTo = [...S.c]; updateAnimLabels(); };
document.getElementById('animSpeed').addEventListener('input', e => {
  S.animSpeed = parseFloat(e.target.value);
  document.getElementById('lbl-animspeed').textContent = 'Speed: ' + S.animSpeed.toFixed(1) + 'x';
});

document.querySelectorAll('.mode-button').forEach(btn => {
  btn.addEventListener('click', () => {
    S.animMode = btn.dataset.mode;
    document.querySelectorAll('.mode-button').forEach(b => b.classList.toggle('active', b.dataset.mode === S.animMode));
  });
});

document.getElementById('playBtn').onclick = () => {
  S.animating = !S.animating;
  if (S.animating) S.animProgress = 0;
  updatePlayBtn();
};

document.getElementById('resetAnim').onclick = () => {
  S.animProgress = 0;
  S.animating = false;
  S.c = [...S.animCFrom];
  syncSlidersFromState();
  updatePlayBtn();
};

// ===== EXPORT =====
document.getElementById('exportPNG').onclick = () => {
  const link = document.createElement('a');
  link.download = `julia_${S.c[0].toFixed(3)}_${S.c[1].toFixed(3)}_${Date.now()}.png`;
  link.href = canvas.toDataURL('image/png');
  link.click();
};

document.getElementById('exportJSON').onclick = () => {
  const settings = {c:S.c, center:S.center, zoom:S.zoom, iterations:S.iterations, escapeRadius:S.escapeRadius, paletteName:S.paletteName, brightness:S.brightness, colorCycleOffset:S.colorCycleOffset};
  const blob = new Blob([JSON.stringify(settings, null, 2)], {type:'application/json'});
  const link = document.createElement('a');
  link.download = `julia-settings-${Date.now()}.json`;
  link.href = URL.createObjectURL(blob);
  link.click();
  URL.revokeObjectURL(link.href);
};

document.getElementById('importJSON').onclick = () => document.getElementById('importFile').click();
document.getElementById('importFile').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    try {
      const s = JSON.parse(ev.target.result);
      if (s.c) S.c = s.c;
      if (s.center) S.center = s.center;
      if (s.zoom) S.zoom = s.zoom;
      if (s.iterations) { S.iterations = s.iterations; document.getElementById('iterations').value = s.iterations; document.getElementById('lbl-iter').textContent = 'Iterations: ' + s.iterations; }
      if (s.escapeRadius) { S.escapeRadius = s.escapeRadius; document.getElementById('escapeRadius').value = s.escapeRadius; }
      if (s.brightness) { S.brightness = s.brightness; document.getElementById('brightness').value = s.brightness; }
      if (s.paletteName && palettes[s.paletteName]) { S.paletteName = s.paletteName; S.palette = palettes[s.paletteName]; buildPaletteGrid(); }
      syncSlidersFromState();
    } catch(err) { alert('Invalid settings file'); }
  };
  reader.readAsText(file);
});

document.getElementById('copyURL').onclick = () => {
  const p = new URLSearchParams();
  p.set('cr', S.c[0].toFixed(6)); p.set('ci', S.c[1].toFixed(6));
  p.set('cx', S.center[0].toFixed(6)); p.set('cy', S.center[1].toFixed(6));
  p.set('z', S.zoom.toFixed(4)); p.set('i', S.iterations); p.set('p', S.paletteName);
  const url = location.origin + location.pathname + '?' + p.toString();
  navigator.clipboard.writeText(url).then(() => {
    const btn = document.getElementById('copyURL');
    btn.textContent = 'Copied!';
    setTimeout(() => btn.textContent = 'Copy Share URL', 2000);
  });
};

document.getElementById('resetView').onclick = () => { S.center = [0,0]; S.zoom = 1; };

// ===== LOAD FROM URL =====
(function() {
  const p = new URLSearchParams(location.search);
  if (!p.has('cr')) return;
  S.c = [parseFloat(p.get('cr')), parseFloat(p.get('ci'))];
  S.center = [parseFloat(p.get('cx')||'0'), parseFloat(p.get('cy')||'0')];
  S.zoom = parseFloat(p.get('z')||'1');
  S.iterations = parseInt(p.get('i')||'200');
  const pName = p.get('p') || 'Electric Dreams';
  if (palettes[pName]) { S.paletteName = pName; S.palette = palettes[pName]; }
  syncSlidersFromState();
  document.getElementById('iterations').value = S.iterations;
  document.getElementById('lbl-iter').textContent = 'Iterations: ' + S.iterations;
  buildPaletteGrid();
})();
</script>
</body>
</html>
